---
layout: post
title: 네트워크 기본 정리(ING)
description: >
excerpt_separator: <!--more-->

---

<!--more-->

# 네떡공부~

## PDU(Protocol Data Unit) - OSI 모델에서의 데이터 단위
- Message : 응용 프로그램이 소켓을 통해 보내는 데이터 단위
- Segment : TCP통신에서의 데이터 단위
- Datagram : UDP통신에서의 데이터 단
- Packet : 네트워크 계층에서의 데이터 단위
- Frame : 데이터 링크 계층에서의 데이터 단위
- Bit : 물리 계층에서의 데이터 단위

## OSI 7계층
#### 1. 1계층 - 물리 계층(Physical Layer)
- 이 계층에서는 단지 `데이터를 전달`만 할 뿐 전송하려는 데이터가 무엇인지, 어떤 에러가 있는지 등에는 전혀 신경 쓰지 않는다.
- 통신단위 : 1, 0(전기적으로 On, Off 상태)
- 통신 케이블, 리피터, 허브 등을 통해 전송

#### 2. 2계층 - 데이터 링크 계층(DataLink Layer)
- 송수신되는 정보의 오류와 흐름을 관리하여 `안전한 정보의 전달`을 수행할 수 있도록 도와주는 역할
- 브릿지나 스위치를 통해 `맥주소`를 가지고 물리계층에서 받은 정보를 전달한다.
- `Point to Point` 간의 신뢰성 있는 전송을 보장하기 위해 `CRC(순환 중복 검사, cyclic redundancy check)`기반의 오류 제어와 흐름 제어가 필요하다.
  - 신뢰성 있는 전송을 위해 오류 검출 및 회복을 위한 `오류 제어` 기능 수행
  - 송수신 측의 속도 차이 해결을 위해 `흐름 제어` 기능 수행
- ex) 이더넷, HDLC, ADCCP, LLC, ALOHA, Packet Switching Network

#### 3. 3계층 - 네트워크 계층(Network Layer)
- 경로를 선택하고 주소를 정하고 경로에 따라 데이터를 목적지까지 가장 안전하고 빠르게 전달
- 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 `QoS`를 제공하기 위한 기능적, 절차적 수단을 제공한다.

#### 4. 4계층 - 전송 계층(Transport Layer)
- 종단 간에 오류제어 및 흐름제어를 통해 신뢰성 있고 정확한 데이터 전송을 담당
- **UDP(User Datagram Protocol)**
  - `비연결형 프로토콜`
  - 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다.
  - 종종 클라이언트는 서버로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면, 클라이언트는 time out 되고 다시 시도할 수 있다.
- **TCP(Transmission Control Protocol)**
  - 대부분의 인터넷 응용분야들은 신뢰성과 순차적인 전달을 필요로 하는데 `UDP`로는 이를 만족시킬 수 없으므로 탄한 것이 `TCP`이다.
  - `TCP`서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. 각 소켓은 호스트의 IP주소와 그 호스트에 국한된 16비트로 구성된 `포트`라고 불리는 소켓 번호를 갖는다.
  - **전이중(full-duplex) 방식**
    - 전송이 양방향으로 동시에 일어날 수 있음
  - **점대점(point to point) 방식**
    - 각 연결이 정확히 2개의 종단점을 가지고 있음
  - **TCP Header**
    - `TCP Header`에는 `Code Bit(Flag bit)`라는 부분이 존재한다. 이 부분은 총 **6Bit**로 이루어져 있으며 각각 한 bit들이 의미를 갖고 있다. 
    - **Urg-Ack-Psh-Rst-Syn-Fin** 순서로 되어 있으며 해당 위치의 bit가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다.
    - 예를들어 `SYN`패킷일 경우에는 `000010`이 되고, `ACK`패킷일 경우에는 `010000`이 되는 것이다.

- TCP랑 UDP는 다시 따로 크게 정리;;


#### 5. 5계층 - 세션 계층(Session Layer)



#### 6. 6계층 - 표현 계층(Presentation Layer)



#### 7. 7계층 - 응용 계층(Application Layer)



## Nagle Algorithm(네이글 알고리즘)
#### 가능하면 조금씩 여러 번 보내지 말고, 한 번에 많이 보내라
- 일반적인 TCP 통신에서는 상대방이 패킷을 받았는지 안 받았는지 확인하기 위해서, 데이터를 받은 쪽에서 `ACK`신호를 보낸다. `ACK`신호를 확인해야 송신부에서는 패킷 전송이 제대로 되었음을 확인하고 그 다음 패킷을 계속해서 전송할 수 있다.
- 예를 들어 'HBJJ' 라는 단어를 패킷으로 보낸다고 할 때, 'H' 를 전송한 다음 상대방으로부터 `ACK`를 받으면 'B'를 전송, 또 `ACK`를 받은 다음 'J'를 전송하는 형태로 한 글자씩 차례대로 전송하게 된다.
- 하지만, `Nagle Algorithm`을 적용하게 되면 처음에 'H'를 전송한 다음 상대방으로부터 `ACK`를 받기 전까지 'HBJJ'에 대한 패킷 정보를 송신 버퍼에 저장한 다음 `ACK`가 오면 여러 개의 패킷을 모아서 한 번에 전송하게 된다.
- **장점**
  - 같은 양의 데이터라도 한 번에 많이 보내기 때문에 데이터 전송 횟수가 줄어들기 때문에 네트워크의 효율성이 높아진다.
- **단점**
  - `ACK`를 받을 때까지 패킷을 모으고 있기 때문에 반응 속도가 느려진다.

## 3-way-handshake
장치들 사이에 논리적인 연결을 성립하기 위하여 **3-way-handshake** 를 사용한다.

[사진 넣기]

1. `Client`가 `Server`에 접속을 요청하는 `SYN(a)` 패킷을 보낸다.
2. `Server`는 `Client`의 요청인 `SYN(a)`를 받고 `Client`에게 요청을 수락한다는 `ACK(a+1)`와 `SYN(b)`이 설정된 패킷을 발송한다.
3. `Client`는 `Server`의 수락 응답인 `ACK(a+1)`와 `SYN(b)` 패킷을 받고 `ACK(b+1)`를 `Server`로 보내면 연결이 성립된다.

## 4-way-handshake
연결을 해제하기 위하여 **4-way-handshake** 를 사용한다.

[사진 넣기]

1. `Client`가 연결을 종료하겠다는 `FIN플래그`를 전송한다.
2. `Server`는 `Client`의 **요청(FIN)**을 받고 확인 메시지로 `ACK`를 보내고, 데이터를 모두 보낼 때까지 잠깐 `TIME_OUT`이 된다.
3. 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 `Client`에게 `FIN플래그`를 전송한다.
4. `Client`는 `FIN메시지`를 확인했다는 `ACK`를 보낸다.
5. `Client`의 `ACK`를 받은 `Server`는 소켓 연결을 **close**한다.
6. `Client`는 아직 `Server`로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동엔 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다.`(TIME_WAIT)`

### 왜 2-way가 아니라 3-way일까?
- **TCP connection**은 양방향성이다. `Client`에서 `Server`에게 존재를 알리고 패킷을 보낼 수 있다는 것을 알리듯, `Server`에서도 `Client`에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 한다. 그렇기 때문에 **2-way-handshake**로는 부족하다.

### 왜 Sequence Number를 난수로 생성해서 보낼까?
- **connection**을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다.
- 서버 측에서는 패킷의 `SYN`을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 **connection**으로부터 오는 패킷으로 인식할 수 있다.
- 이러한 문제가 발생할 가능성을 줄잉기 위해서 난수로 `ISN`을 설정하는 것이다.**(ISN : 초기 sequence number)**
```
